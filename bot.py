# -*- coding: utf8 -*-


import telebot
from telebot import types
import random

bot = telebot.TeleBot('6878576355:AAE2VQUpbyQcKUV1EgTpQX4fXbhXNFpW6iM')


ques = ['Что такое LA? В каких единицах измеряется?',
'Что будет если на сервере LA = 100?',
'Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?',
'Представлен вывод команды top. Что означает каждая запись в выводе?\ntop - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10\nTasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie\n%Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st\nKiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache\nKiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem',
'Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?',
'Как в утилите top в Linux посмотреть какой командой был запущен процесс?',
'Где хранятся имена файлов/директорий?',
'Как удалить файл с именем -rf?',
'Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?',
'Для чего нужна переменная окружения PATH?',
'Как посмотреть нагрузку на диски?',
'Что такое файл в понятиях Unix-like операционных системах?',
'Что такое RAID? Какие массивы бывают?',
'При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?',
'В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?',
'Как остановить выполнение скрипта в bash при возникновении ошибки в команде?',
'Что в bash скрипте означает команда set -euo pipefail?',
'Как активировать debug режим в bash?',
'Что значит $@ в bash?',
'Какой код сигнала будет выполнен при исполнении команды kill ?',
'Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?',
'Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?',
'Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?',
'В каком файле находится информация о смонтированных каталогах в файловую систему?',
'Что выведет команда cat a и почему?\nmkdir /tmp/abc\ncd /tmp/abc\nls >a 2>b\ncat a',
'В bash-скрипте указан атрибут оболочки set -x. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?',
'Что такое системный вызов, какие они бывают?',
'Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?',
'Что такое inode? Какая информация там хранится?',
'Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.',
'Какие состояния процессов существуют? Что значит состояние процесса D?',
'Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?',
'Что такое файловый дескриптор? Какая информация там хранится?',
'Что такое buffer/cache память? Для чего нужна?',
'Представлен вывод команды free.\n$ free -m\ntotal used free shared buff/cache available\nMem: 6930 3598 843 183 2489 2919\nSwap: 15999 4 15995\nПочему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?',
'Порядок загрузки дистрибутива Linux.',
'Что такое GitFlow?',
'Чем merge отличается от rebase?',
'Чем tag отличается от branch?',
'В ветке develop есть коммит с изменениями, которые нужно перенести в ветку master. Как это сделать?',
'Для чего нужна команда git commit --amend?',
'Что такое Trunk-based development?',
'Состояние репозитория ушло на много коммитов вперед. Как откатить весь репозиторий к определенному коммиту?',
'В репозиторий запушен коммит с изменениями в двух файлах. Как откатить изменения этого коммита?',
'Что такое Docker? В чем отличие контейнера от образа?',
'Какие инструкции есть у Dockerfile?',
'Чем отличается CMD от ENTRYPOINT в Dockerfile?',
'Чем отличается COPY от ADD в Dockerfile?',
'Какие есть best practices для написания Dockerfile?',
'Какие типы сетевых драйверов используются в docker?',
'Что такое эфемерные контейнеры?'
]


ans = ['Load average (средняя загрузка) - это метрика, которая показывает среднее количество процессов, ожидающих выполнения в определенный момент времени. Она измеряется в единицах нагрузки, которые представляют собой отношение количества активных процессов к количеству процессоров. Например, значение 1 означает, что процессор полностью загружен, а значение 2 - что в два раза больше процессов, чем процессоров. Обычно load average выражается в трех значениях: за последнюю минуту, за последние 5 минут и за последние 15 минут.',
       'Если на сервере load average (LA) достигнет значения 100, это будет означать, что на каждый процессор приходится 100 процессов, ожидающих выполнения. Это может привести к снижению производительности сервера и увеличению времени отклика для пользователей.',
       'Возможно, на сервере установлено достаточное количество процессоров, чтобы обеспечить нормальную работу при высокой нагрузке. Также может быть оптимизирована работа приложений и сервисов, чтобы они не создавали большое количество процессов и не нагружали сервер. Кроме того, высокие показатели LA могут быть временным явлением и не приводить к проблемам, если нагрузка на сервер снизится в ближайшее время.',
       'top - текущее время и длительность работы системы. up - время, прошедшее с момента последней перезагрузки. user - количество пользователей, находящихся в системе. load average - средняя загрузка процессора за последние 1, 5 и 15 минут. Tasks - общее количество процессов на сервере, разделенное по состояниям (запущенные, работающие, спящие, остановленные, зомби). процент использования процессора по различным типам задач. Каждый тип задачи представлен своим сокращением. KiB Mem - информация о памяти: общее количество, свободное, используемое и буферизованное. KiB Swap - информация о разделе подкачки: общее количество, свободное и используемое. avail Mem - доступная для использования память (объединение свободной и буферизованной памяти).',
       'В утилите top в Linux можно посмотреть нагрузку на каждое ядро процессора, нажав клавишу 1 на клавиатуре. Это отобразит информацию о каждом ядре процессора в отдельности. Также можно использовать команду mpstat -P ALL для просмотра нагрузки на каждое ядро процессора в терминале.',
       'Для просмотра команды, с помощью которой был запущен процесс, можно использовать следующую команду в утилите top: c или c (где - идентификатор процесса). Также можно использовать команду ps -p -o command для просмотра команды запуска процесса.',
       'Имена файлов и директорий хранятся в inode (индексный дескриптор) файловой системы.',
       'Файл с именем -rf можно удалить с помощью команды rm. Для этого необходимо выполнить следующую команду в терминале:rm -rf – -rf',
       'Описание дескриптора можно посмотреть с помощью команды ls -l. В выводе этой команды в столбце Permissions будет указано, какой тип дескриптора у файла. ремя последней модификации файла можно посмотреть с помощью команды ls -l или stat <имя_файла>. В выводе этих команд будет указана дата и время последнего изменения файла в столбце Last modified или Modify.',
       'Переменная окружения PATH определяет список каталогов, в которых операционная система будет искать исполняемые файлы при выполнении команд в терминале. Это позволяет запускать программы и скрипты без указания полного пути к ним. Переменная PATH также позволяет добавлять новые каталоги для поиска исполняемых файлов, что упрощает управление программами и скриптами на компьютере.',
       'в Linux - командами df и top.',
       'Это именованная последовательность байтов, хранящаяся на устройстве хранения информации (например, жестком диске). Файлы могут содержать различные типы данных, такие как текст, изображения, аудио и видео. В Unix-like системах файлы имеют свойства, такие как права доступа, время создания и модификации, а также могут быть организованы в структуру каталогов и подкаталогов. Файлы являются основным способом хранения и организации информации в Unix-like системах.',
       'RAID (Redundant Array of Independent Disks) - это технология хранения данных, которая объединяет несколько физических дисков в один логический диск для повышения производительности и надежности хранения данных. \nВиды массивов: \nRAID 0 (Striping) - данные разбиваются на блоки и записываются на несколько дисков одновременно, что повышает скорость чтения и записи, но не обеспечивает защиту от сбоев дисков. \nRAID 1 (Mirroring) - данные дублируются на двух дисках, что обеспечивает повышенную надежность хранения данных, но не увеличивает скорость чтения и записи. \nRAID 5 (Striping with Parity) - данные разбиваются на блоки и записываются на несколько дисков, а также используется дополнительный диск для хранения информации о четности данных. Это позволяет восстановить данные при сбое одного из дисков. \nRAID 6 (Striping with Double Parity) - аналогично RAID 5, но используется два диска для хранения информации о четности, что повышает надежность хранения данных. \nRAID 10 (Mirroring and Striping) - комбинация RAID 1 и RAID 0, когда данные дублируются на нескольких дисках и одновременно разбиваются на блоки для повышения производительности. \nКроме того, существуют также и другие типы RAID-массивов, такие как RAID 2, RAID 3, RAID 4, RAID 7, но они редко используются в современных системах хранения данных.',
       'RAID 6 может обеспечить работоспособность при одновременном выходе из строя двух дисков. Это возможно благодаря наличию двух дополнительных дисков для хранения информации о четности.',
       'Переменная, объявленная с помощью export VAR=VALUE, будет доступна не только в текущем скрипте, но и во всех дочерних процессах. Таким образом, она будет экспортирована в окружение системы и будет доступна для использования в других скриптах или командах. Переменная, объявленная как VAR=VALUE, будет доступна только в текущем скрипте и не будет экспортирована в окружение системы. Она будет доступна только внутри текущего скрипта и не будет видна другим процессам или скриптам.',
       'CTRL + C',
       'Команда set -euo pipefail устанавливает опции для оболочки bash, которые позволяют управлять обработкой ошибок и поведением скрипта. Опция e (errexit) указывает оболочке завершать выполнение скрипта, если в нем происходит ошибка. Опция u (nounset) указывает оболочке выдавать ошибку, если в скрипте используется неопределенная переменная. Опция o (pipefail) указывает оболочке завершать выполнение скрипта, если одна из команд в конвейере (pipeline) завершается с ошибкой. Опция pipefail также позволяет получить код ошибки от последней команды в конвейере, а не только от последней команды в скрипте.',
       'Для активации debug режима в bash можно использовать опцию -x при запуске скрипта или включить ее внутри скрипта с помощью команды set -x. Это позволит выводить на экран все команды и их аргументы, которые выполняются в процессе работы скрипта. Также можно использовать опцию -v для вывода на экран текста команд перед их выполнением.',
       'В bash @ представляет собой список всех аргументов командной строки, переданных при запуске скрипта или функции.',
       'При исполнении команды kill будет выполнен код сигнала SIGTERM (15), который по умолчанию используется для завершения процесса.',
       'Для выполнения фильтрации вывода команды можно использовать оператор перенаправления вывода 2>, который позволяет перенаправить только STDERR в указанный файл или устройство.',
       'who или w. Например, who -u покажет список всех пользователей, вошедших в систему, с указанием времени входа и активных процессов.',
       'Для отключения ssh аутентификации по паролю необходимо отредактировать файл /etc/ssh/sshd_config и изменить параметр PasswordAuthentication на no. После этого необходимо перезапустить сервис sshd для применения изменений.',
       'Информация о смонтированных каталогах находится в файле /etc/fstab.',
       'Команда cat a выведет содержимое файла a, который был создан в каталоге /tmp/abc при помощи команды ls. Это произойдет потому, что команда ls с помощью оператора > перенаправила вывод своего выполнения в файл a. При этом ошибка, которая могла возникнуть при выполнении команды ls, будет перенаправлена в файл b.',
       'Чтобы скрипт продолжил свою работу при возникновении ошибки в определенной команде, необходимо добавить после этой команды оператор || и указать команду, которая будет выполняться в случае ошибки. Например, если команда с ошибкой называется command, то нужно изменить ее на command || true. Таким образом, если команда command завершится с ошибкой, то вместо остановки скрипта будет выполнена команда true, которая не делает ничего и позволяет продолжить работу скрипта.',
       'Системный вызов (system call) - это механизм взаимодействия между пользовательским приложением и операционной системой. Он позволяет приложению обращаться к функциям и сервисам операционной системы для выполнения определенных задач, например, создания файлов, управления процессами, сетевым взаимодействием и т.д. Создание и управление процессами - например, fork(), exec(), wait(). Работа с файлами и директориями - например, open(), read(), write(). Управление памятью - например, mmap(), brk(). Сетевое взаимодействие - например, socket(), connect(), send(), recv(). Управление устройствами - например, ioctl(), read(), write(). Управление ресурсами - например, time(), getpid(), getuid().',
       'Сигнал в Unix - это средство межпроцессного взаимодействия, которое позволяет операционной системе уведомлять процессы о различных событиях, например, о завершении работы другого процесса или о необходимости завершения работы. Сигналы используются для обработки исключительных ситуаций, синхронизации процессов и управления ресурсами. Сигнал SIGKILL (9) используется для немедленного завершения процесса, а сигнал SIGTERM (15) - для плавного завершения. Основная разница между 9 и 15 сигналами заключается в том, что SIGKILL не может быть перехвачен или игнорирован процессом, а SIGTERM может быть перехвачен и обработан, например, для сохранения данных перед завершением работы.',
       'Inode (index node) в Unix - это структура данных, которая хранит информацию о файле или каталоге в файловой системе. Каждый файл или каталог имеет свой уникальный inode, который идентифицирует его и хранит метаданные о нем. В inode хранится следующая информация: идентификатор владельца файла или каталога; идентификатор группы владельцев; размер файла в байтах; дата и время создания, последнего доступа и последней модификации; права доступа к файлу или каталогу; колличество ссылок на файл или каталог; номер блока данных, где хранится содержимое файла или каталога, номер блока данных, где хранится список блоков данных, составляющих файл или каталог; тип файла.',
       'Hard link (жесткая ссылка) - это специальный тип ссылки на файл в Unix-подобных системах, который позволяет создать несколько имен для одного и того же файла. При этом все эти имена имеют одинаковые права доступа и указывают на один и тот же inode. То есть, если удалить одно из имен, файл останется доступным через остальные имена. Разница между hard link и soft link заключается в том, что soft link (символическая ссылка) является отдельным файлом, который содержит путь к другому файлу. При удалении исходного файла, на который указывает символическая ссылка, она становится бессмысленной. Пример практического применения hard link: Создание резервных копий файлов. Жесткие ссылки позволяют создать несколько копий одного файла без необходимости дублирования данных. Пример практического применения soft link: Создание ссылок на часто используемые файлы или каталоги. Например, можно создать символическую ссылку на папку с программами и добавить ее в переменную PATH, чтобы иметь быстрый доступ к этим программам из любой директории.',
       'Существует 5 основных состояний процессов: New - новый процесс, который только что был создан и еще не выполнялся. Ready - процесс готов к выполнению и ожидает своей очереди на выполнение. Running - процесс выполняется на процессоре. Waiting - процесс ожидает события, которое может привести к его выполнению (например, завершение операции ввода-вывода). Terminated - процесс завершил свое выполнение. Состояние процесса D означает, что процесс заблокирован и ожидает завершения операции ввода-вывода. Это может быть вызвано, например, если процесс пытается получить доступ к файлу или устройству, которые заняты другим процессом. Как только операция ввода-вывода будет завершена, процесс перейдет в состояние Ready и будет готов к выполнению.',
       'Процесс-зомби (zombie process) - это процесс, который завершил свое выполнение, но его родительский процесс еще не получил информацию о его завершении. Такой процесс не занимает ресурсы процессора или памяти, но его идентификатор процесса все еще существует в системе. Обычно процесс-зомби создается, когда родительский процесс не обрабатывает сигнал о завершении своего дочернего процесса. \n Процесс-сирота (orphan process) - это процесс, который продолжает выполняться после завершения своего родительского процесса. Такой процесс может быть создан, например, если родительский процесс завершается неожиданно или если родительский процесс является демоном и не завершается после запуска дочернего процесса. \nСоздать зомби-процесс самостоятельно невозможно, так как это происходит автоматически при завершении процесса и отсутствии обработки сигнала о его завершении со стороны родительского процесса. Однако, можно предотвратить появление зомби-процессов, правильно обрабатывая сигналы о завершении дочернего процесса в родительском процессе.',
       'Файловый дескриптор (file descriptor) - это целочисленный идентификатор, который используется для доступа к файлам или другим ресурсам в операционной системе. Он представляет собой ссылку на открытый файл или устройство и содержит информацию о его состоянии и расположении в памяти. \n Файловый дескриптор хранит информацию о текущем положении в файле, правах доступа к файлу, режиме открытия (чтение, запись, обновление), а также о других параметрах, необходимых для работы с файлом. Он также может содержать ссылку на таблицу операций для выполнения различных операций с файлом, таких как чтение, запись, перемещение указателя на нужное место и т.д.',
       'Buffer/cache память - это часть оперативной памяти компьютера, которая используется для временного хранения данных, которые были недавно загружены или записаны. Она представляет собой комбинацию буферной и кэш-памяти. \n Buffer/cache память используется для оптимизации работы с файлами и другими ресурсами в операционной системе. Она позволяет ускорить доступ к данным и уменьшить количество операций ввода-вывода, что повышает производительность системы в целом.',
       'Доступная память (available) включает в себя не только свободную память (free), но и буферную и кэш-память. В данном случае, доступная память составляет 2919 МБ, что включает в себя 843 МБ свободной памяти и 2489 МБ буферной/кэш-памяти. Это означает, что из общего объема памяти в 6930 МБ, только 843 МБ в данный момент не используются для хранения данных. Остальная память используется для буферизации и кэширования данных, чтобы ускорить доступ к ним.',
       'Шаг 1: Выбрать нужный дистрибутив Linux. \nШаг 2: Перейти на официальный сайт выбранного дистрибутива. \nШаг 3: Найти раздел загрузки или скачать дистрибутив. \nШаг 4: Выбрать подходящую версию для своей системы (32-бит или 64-бит). \nШаг 5: Скачать файл ISO образа дистрибутива. \nШаг 6: Создать загрузочную флешку или DVD с помощью специальной программы (например, Rufus или Etcher). \nШаг 7: Подготовить компьютер к установке Linux, сделав резервную копию важных данных и проверив совместимость оборудования. \nШаг 8: Подключить загрузочное устройство к компьютеру и перезагрузить его. \nШаг 9: В настройках BIOS выбрать загрузку с подключенного устройства. \nШаг 10: Запустить установку дистрибутива, следуя инструкциям на экране. \nШаг 11: Выбрать язык и часовой пояс. \nШаг 12: Создать разделы для установки (если требуется). \nШаг 13: Выбрать место для установки загрузчика GRUB. \nШаг 14: Дождаться завершения установки. \nШаг 15: Перезагрузить компьютер и наслаждаться работой в новой операционной системе Linux.',
       'GitFlow - это методология управления версиями и разработкой программного обеспечения, основанная на системе контроля версий Git. Она предоставляет набор правил и рекомендаций для организации рабочего процесса в команде разработчиков, позволяя эффективно управлять изменениями кода, выпускать новые версии продукта и поддерживать стабильность и надежность программного обеспечения. GitFlow включает в себя использование нескольких веток для различных целей (например, ветки для разработки новых функций, исправления ошибок, релизов и т.д.), а также определенные правила для слияния и публикации изменений. Эта методология широко используется в различных проектах, особенно в коммерческой разработке ПО.',
       'Merge - это процесс, при котором изменения из одной ветки (например, ветки для разработки новой функции) объединяются с другой веткой (например, основной веткой продукта). При этом создается новый коммит, который содержит все изменения из обеих веток. Это позволяет сохранить историю изменений и отслеживать, какие изменения были объединены. \n Rebase - это процесс, при котором изменения из одной ветки применяются к другой ветке путем переигрывания коммитов. В результате, история изменений становится линейной, а все коммиты из одной ветки добавляются непосредственно перед коммитами из другой ветки. Это позволяет сохранить более чистую и простую историю изменений, но может быть опасным, если другие разработчики работают с той же веткой и не ожидают таких изменений. \nТаким образом, основное отличие между merge и rebase заключается в том, каким образом происходит объединение изменений и как это отражается в истории коммитов. Оба подхода имеют свои преимущества и недостатки, и выбор между ними зависит от конкретной ситуации и предпочтений команды разработчиков.',
       'Branch (ветка) - это отдельная линия разработки, которая создается для работы над определенной функцией или задачей. Ветки позволяют разработчикам работать над различными изменениями параллельно и объединять их в основную ветку при необходимости. Ветки могут быть созданы, переключены и удалены в любой момент. \n \n Tag (метка) - это статическая ссылка на определенный коммит в истории изменений. Она используется для пометки важных точек в разработке, таких как релизы или версии продукта. В отличие от веток, метки не могут быть переключены или удалены, они остаются на том же коммите всегда. \n \nТаким образом, основное отличие между tag и branch заключается в их назначении. Ветки используются для организации работы над изменениями, а метки - для пометки важных точек в разработке. Оба подхода позволяют управлять историей изменений и отслеживать версии продукта, но в разных целях.',
       'Для переноса изменений из ветки develop в ветку master можно использовать команду merge или rebase. \nMerge: \nПереключитесь на ветку master с помощью команды git checkout master\nВыполните команду git merge develop, которая объединит изменения из ветки develop в текущую ветку (master)\nЗакоммитьте изменения и отправьте их на удаленный репозиторий с помощью команды git push\nRebase: \nПереключитесь на ветку master с помощью команды git checkout master\nВыполните команду git rebase develop, которая перенесет изменения из ветки develop на вершину ветки master\nЗакоммитьте изменения и отправьте их на удаленный репозиторий с помощью команды git push',
       'Команда git commit --amend используется для изменения последнего коммита. Она позволяет добавить новые файлы или изменить сообщение коммита без создания нового коммита. Это полезно, если вы забыли включить какие-то файлы в предыдущий коммит или хотите исправить опечатку в сообщении коммита. Также эта команда может быть использована для объединения нескольких коммитов в один.',
       'Trunk-based development (TBD) - это подход к разработке программного обеспечения, при котором все разработчики работают в одной ветке (trunk) репозитория. В этом подходе вся разработка происходит в единой ветке, без создания дополнительных веток для различных задач или функциональности.',
       'Для отката всего репозитория к определенному коммиту можно использовать команду git reset с параметром –hard, указывающим на необходимый коммит.',
       'Использовать команду git revert <хеш коммита>, чтобы создать новый коммит, который отменяет изменения последнего коммита. После этого необходимо запушить изменения в удаленный репозиторий с помощью команды git push origin <название ветки>.',
       'Docker - это открытая платформа для разработки, доставки и запуска приложений в контейнерах. Она позволяет упаковать приложение и все его зависимости в единую сущность - контейнер, который может быть запущен на любой совместимой с Docker системе.\n Контейнер - это изолированное окружение, в котором запускается приложение и все его зависимости. Он содержит только необходимые компоненты для работы приложения и использует общую операционную систему с хост-машиной. Контейнеры могут быть запущены на любой совместимой с Docker системе без необходимости установки дополнительных зависимостей.\nОбраз - это шаблон для создания контейнера. Он содержит все необходимые компоненты и настройки для запуска приложения в контейнере. Образы могут быть использованы для создания нескольких контейнеров с одним и тем же приложением. Они также могут быть обновлены и распространены через Docker Hub или другие репозитории.',
       'FROM - указывает базовый образ, на основе которого будет создан новый образ. RUN - выполняет команды внутри контейнера во время создания образа. COPY - копирует файлы и папки из локальной файловой системы в контейнер. WORKDIR - устанавливает рабочую директорию для следующих инструкций. ENV - устанавливает переменные окружения внутри контейнера. EXPOSE - указывает порты, которые должны быть открыты при запуске контейнера. CMD - определяет команду, которая будет выполнена при запуске контейнера.',
       'В общем случае, ENTRYPOINT используется для установки основной команды, а CMD - для установки аргументов для этой команды. Например, если в ENTRYPOINT указан скрипт для запуска сервера, то в CMD можно указать порт, на котором должен работать сервер.',
       'Основное отличие между ними заключается в том, что ADD имеет дополнительные функции, такие как автоматическое распаковывание архивов и загрузка файлов по URL. Однако, по сути, они обе выполняют одну и ту же задачу - копирование файлов.',
       'Использовать официальные базовые образы: Лучше всего использовать официальные базовые образы, такие как Ubuntu, Debian или Alpine, вместо создания своего собственного. Минимизировать количество слоев: Чем меньше слоев в образе, тем легче его поддерживать и обновлять. Использовать .dockerignore файл: Этот файл позволяет исключить ненужные файлы и директории из контекста сборки, что уменьшает размер образа.',
       'Bridge: Самый распространенный тип сетевого драйвера, который создает виртуальную сеть и подключает контейнеры к этой сети. Host: Позволяет контейнеру использовать сетевые интерфейсы хоста вместо создания виртуальной сети. Overlay: Позволяет создавать виртуальные сети, которые могут объединять несколько хостов. Macvlan: Позволяет контейнерам иметь собственный MAC-адрес и быть частью физической сети. None: Создает контейнер без доступа к сети. Network plugins: Позволяют использовать сторонние плагины для настройки сетевых функций контейнера.',
       'Эфемерные контейнеры - это контейнеры, которые создаются и используются только на короткий период времени для выполнения определенной задачи. Они могут быть запущены, выполнить свою функцию и затем удалены, чтобы освободить ресурсы. Это позволяет эффективно использовать ресурсы и улучшает масштабируемость приложений.']


@bot.message_handler(commands=['start'])
def main(message):
    bot.send_message(message.chat.id, 'Привет, это бот с вопросами по курсу "Введение в операционные системы и инструменты разработки" и ответами на них.\n')
    bot.send_message(message.chat.id, 'Список команд: \n'
                                      '/questions - список вопросов\n'
                                      '/questions_ans - вопросы и ответы\n'
                                      '/номер_вопроса - выдает вопрос из списка, ответ к нему и откуда взят ответ\n'
                                      '/random - выбирает случайные два вороса из списка\n')


@bot.message_handler(commands=['questions'])
def main(message):
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton('Список вопросов', url='c2072.myvds.org:1339'))
    bot.reply_to(message, 'Список вопросов', reply_markup=markup)


@bot.message_handler(commands=['questions_ans'])
def main(message):
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton('Список вопросов и ответов', url='http://c2072.myvds.org/~fit12_29/'))
    bot.reply_to(message, 'Список вопросов и тветов', reply_markup=markup)


@bot.message_handler(commands=['random'])
def main(message):
    first_num = random.randint(0, 50)
    second_num = first_num
    global first
    global second
    first = first_num
    while (second_num == first_num):
        second_num = random.randint(0, 50)
    second = second_num
    markup = types.InlineKeyboardMarkup()
    btn1 = types.InlineKeyboardButton('Посмотреть ответы на оба вопроса', callback_data='one_and_two')
    btn2 = types.InlineKeyboardButton('Посмотреть ответ на первый вопрос', callback_data='one')
    btn3 = types.InlineKeyboardButton('Посмотреть ответ на второй вопрос', callback_data='two')
    markup.row(btn1)
    markup.row(btn2, btn3)
    bot.send_message(message.chat.id, ques[first_num] + "\n" + "\n" + ques[second_num], reply_markup=markup)


@bot.callback_query_handler(func=lambda callback: True)
def answer_random(callback):
    if callback.data == 'one_and_two':
        bot.send_message(callback.message.chat.id, ans[first] + "\n" + "\n" + ans[second])
    elif callback.data == 'two':
        bot.send_message(callback.message.chat.id, ans[second])
    elif callback.data == 'one':
        bot.send_message(callback.message.chat.id, ans[first])


@bot.message_handler(commands=['1'])
def site(message):
    bot.send_message(message.chat.id, ques[0] + '\n' + '\n' + ans[0])


@bot.message_handler(commands=['2'])
def site(message):
    bot.send_message(message.chat.id, ques[1] + '\n' + '\n' + ans[1])


@bot.message_handler(commands=['3'])
def site(message):
    bot.send_message(message.chat.id, ques[2] + '\n' + '\n' + ans[2])


@bot.message_handler(commands=['4'])
def site(message):
    bot.send_message(message.chat.id, ques[3] + '\n' + '\n' + ans[3])


@bot.message_handler(commands=['5'])
def site(message):
    bot.send_message(message.chat.id, ques[4] + '\n' + '\n' + ans[4])


@bot.message_handler(commands=['6'])
def site(message):
    bot.send_message(message.chat.id, ques[5] + '\n' + '\n' + ans[5])


@bot.message_handler(commands=['7'])
def site(message):
    bot.send_message(message.chat.id, ques[6] + '\n' + '\n' + ans[6])


@bot.message_handler(commands=['8'])
def site(message):
    bot.send_message(message.chat.id, ques[7] + '\n' + '\n' + ans[7])


@bot.message_handler(commands=['9'])
def site(message):
    bot.send_message(message.chat.id, ques[8] + '\n' + '\n' + ans[8])


@bot.message_handler(commands=['10'])
def site(message):
    bot.send_message(message.chat.id, ques[9] + '\n' + '\n' + ans[9])


@bot.message_handler(commands=['11'])
def site(message):
    bot.send_message(message.chat.id, ques[10] + '\n' + '\n' + ans[10])


@bot.message_handler(commands=['12'])
def site(message):
    bot.send_message(message.chat.id, ques[11] + '\n' + '\n' + ans[11])


@bot.message_handler(commands=['13'])
def site(message):
    bot.send_message(message.chat.id, ques[12] + '\n' + '\n' + ans[12])


@bot.message_handler(commands=['14'])
def site(message):
    bot.send_message(message.chat.id, ques[13] + '\n' + '\n' + ans[13])

@bot.message_handler(commands=['15'])
def site(message):
    bot.send_message(message.chat.id, ques[14] + '\n' + '\n' + ans[14])


@bot.message_handler(commands=['16'])
def site(message):
    bot.send_message(message.chat.id, ques[15] + '\n' + '\n' + ans[15])


@bot.message_handler(commands=['17'])
def site(message):
    bot.send_message(message.chat.id, ques[16] + '\n' + '\n' + ans[16])


@bot.message_handler(commands=['18'])
def site(message):
    bot.send_message(message.chat.id, ques[17] + '\n' + '\n' + ans[17])


@bot.message_handler(commands=['19'])
def site(message):
    bot.send_message(message.chat.id, ques[18] + '\n' + '\n' + ans[18])


@bot.message_handler(commands=['20'])
def site(message):
    bot.send_message(message.chat.id, ques[19] + '\n' + '\n' + ans[19])


@bot.message_handler(commands=['21'])
def site(message):
    bot.send_message(message.chat.id, ques[20] + '\n' + '\n' + ans[20])


@bot.message_handler(commands=['22'])
def site(message):
    bot.send_message(message.chat.id, ques[21] + '\n' + '\n' + ans[21])


@bot.message_handler(commands=['23'])
def site(message):
    bot.send_message(message.chat.id, ques[22] + '\n' + '\n' + ans[22])


@bot.message_handler(commands=['24'])
def site(message):
    bot.send_message(message.chat.id, ques[23] + '\n' + '\n' + ans[23])


@bot.message_handler(commands=['25'])
def site(message):
    bot.send_message(message.chat.id, ques[24] + '\n' + '\n' + ans[24])


@bot.message_handler(commands=['26'])
def site(message):
    bot.send_message(message.chat.id, ques[25] + '\n' + '\n' + ans[25])


@bot.message_handler(commands=['27'])
def site(message):
    bot.send_message(message.chat.id, ques[26] + '\n' + '\n' + ans[26])


@bot.message_handler(commands=['28'])
def site(message):
    bot.send_message(message.chat.id, ques[27] + '\n' + '\n' + ans[27])


@bot.message_handler(commands=['29'])
def site(message):
    bot.send_message(message.chat.id, ques[28] + '\n' + '\n' + ans[28])


@bot.message_handler(commands=['30'])
def site(message):
    bot.send_message(message.chat.id, ques[29] + '\n' + '\n' + ans[29])


@bot.message_handler(commands=['31'])
def site(message):
    bot.send_message(message.chat.id, ques[30] + '\n' + '\n' + ans[30])


@bot.message_handler(commands=['32'])
def site(message):
    bot.send_message(message.chat.id, ques[31] + '\n' + '\n' + ans[31])


@bot.message_handler(commands=['33'])
def site(message):
    bot.send_message(message.chat.id, ques[32] + '\n' + '\n' + ans[32])


@bot.message_handler(commands=['34'])
def site(message):
    bot.send_message(message.chat.id, ques[33] + '\n' + '\n' + ans[33])


@bot.message_handler(commands=['35'])
def site(message):
    bot.send_message(message.chat.id, ques[34] + '\n' + '\n' + ans[34])


@bot.message_handler(commands=['36'])
def site(message):
    bot.send_message(message.chat.id, ques[35] + '\n' + '\n' + ans[35])


@bot.message_handler(commands=['37'])
def site(message):
    bot.send_message(message.chat.id, ques[36] + '\n' + '\n' + ans[36])


@bot.message_handler(commands=['38'])
def site(message):
    bot.send_message(message.chat.id, ques[37] + '\n' + '\n' + ans[37])


@bot.message_handler(commands=['39'])
def site(message):
    bot.send_message(message.chat.id, ques[38] + '\n' + '\n' + ans[38])

@bot.message_handler(commands=['40'])
def site(message):
    bot.send_message(message.chat.id, ques[39] + '\n' + '\n' + ans[39])


@bot.message_handler(commands=['41'])
def site(message):
    bot.send_message(message.chat.id, ques[40] + '\n' + '\n' + ans[40])


@bot.message_handler(commands=['42'])
def site(message):
    bot.send_message(message.chat.id, ques[41] + '\n' + '\n' + ans[41])


@bot.message_handler(commands=['43'])
def site(message):
    bot.send_message(message.chat.id, ques[42] + '\n' + '\n' + ans[42])


@bot.message_handler(commands=['44'])
def site(message):
    bot.send_message(message.chat.id, ques[43] + '\n' + '\n' + ans[43])

@bot.message_handler(commands=['45'])
def site(message):
    bot.send_message(message.chat.id, ques[44] + '\n' + '\n' + ans[44])


@bot.message_handler(commands=['46'])
def site(message):
    bot.send_message(message.chat.id, ques[45] + '\n' + '\n' + ans[45])


@bot.message_handler(commands=['47'])
def site(message):
    bot.send_message(message.chat.id, ques[46] + '\n' + '\n' + ans[46])


@bot.message_handler(commands=['48'])
def site(message):
    bot.send_message(message.chat.id, ques[47] + '\n' + '\n' + ans[47])


@bot.message_handler(commands=['49'])
def site(message):
    bot.send_message(message.chat.id, ques[48] + '\n' + '\n' + ans[48])


@bot.message_handler(commands=['50'])
def site(message):
    bot.send_message(message.chat.id, ques[49] + '\n' + '\n' + ans[49])


@bot.message_handler(commands=['51'])
def site(message):
    bot.send_message(message.chat.id, ques[50] + '\n' + '\n' + ans[50])


bot.polling(none_stop=True)
